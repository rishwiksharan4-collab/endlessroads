<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Endless Roads - Wave 1</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background:#000;
  touch-action:none;
  font-family:sans-serif;
}
#menu{
  position:fixed;
  inset:0;
  background:#87ceeb;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:20;
}
#menuBox{
  background:#fff;
  padding:20px;
  border-radius:12px;
  text-align:center;
}
button{
  padding:10px 20px;
}
</style>
</head>

<body>

<div id="menu">
  <div id="menuBox">
    <h2>Endless Roads</h2>
    <button id="begin">BEGIN</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/perlin-noise@1.3.1/index.min.js"></script>

<script>
/* -------- SCENE -------- */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);
scene.fog=new THREE.FogExp2(0x87ceeb,0.003);

const camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,2000);
camera.position.set(0,6,10);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

/* -------- LIGHT -------- */
const hemi=new THREE.HemisphereLight(0xffffff,0x444444,1.2);
scene.add(hemi);

const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(100,200,100);
scene.add(sun);

/* -------- TERRAIN CONFIG -------- */
const TILE_SIZE=100;
const TILE_SUB=40; // medium poly
const CHUNK_COUNT=6; // visible tiles
const mountainStrength=30;
let tiles=[];

/* -------- TERRAIN CREATE -------- */
function createTile(zIndex){
  const geo=new THREE.PlaneGeometry(TILE_SIZE,TILE_SIZE,TILE_SUB,TILE_SUB);
  geo.rotateX(-Math.PI/2);

  // apply heights
  for(let i=0;i<geo.attributes.position.count;i++){
    let pos=geo.attributes.position;
    let x=pos.getX(i);
    let z=pos.getZ(i);
    let nx=(x+performance.now()*0.0001)/50;
    let nz=(z+zIndex*TILE_SIZE)/50;
    let h=noise.perlin2(nx,nz)*mountainStrength;
    pos.setY(i,h);
  }
  geo.computeVertexNormals();

  const mat=new THREE.MeshStandardMaterial({
    color:0x77bb66,
    flatShading:false
  });

  const mesh=new THREE.Mesh(geo,mat);
  mesh.position.z=zIndex*TILE_SIZE;
  scene.add(mesh);
  return mesh;
}

/* -------- INIT CHUNKS -------- */
for(let i=0;i<CHUNK_COUNT;i++){
  tiles.push(createTile(i));
}

/* -------- CAR -------- */
const car=new THREE.Mesh(
  new THREE.BoxGeometry(1.5,0.6,3),
  new THREE.MeshStandardMaterial({color:0xffffff})
);
car.position.y=5;
scene.add(car);

/* -------- INPUT -------- */
let keys={};
addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

/* -------- GAME -------- */
let speed=0;
let started=false;
document.getElementById("begin").onclick=()=>{
  document.getElementById("menu").style.display="none";
  started=true;
};

function loop(){
  requestAnimationFrame(loop);

  if(started){
    if(keys["w"]) speed+=0.002;
    if(keys["s"]) speed-=0.002;
    speed*=0.98;
    speed=Math.max(Math.min(speed,1),-0.5);

    car.position.z-=speed*1.2;

    camera.position.lerp(
      new THREE.Vector3(car.position.x,6,car.position.z+12),0.1
    );
    camera.lookAt(car.position);

    // recycle chunks
    tiles.forEach(t=>{
      if(t.position.z - car.position.z > TILE_SIZE*2){
        t.position.z-=TILE_SIZE*CHUNK_COUNT;
      }
    });
  }

  renderer.render(scene,camera);
}

loop();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
